<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Responsive Brick Breaker - Black & White with Screens</title>
<style>
  /* Reset */
  html, body {
    margin: 0; padding: 0; overflow: hidden;
    background: #000;
    color: #eee;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    height: 100vh;
    width: 100vw;
  }

  #landscape-warning {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.95);
    display: none;
    justify-content: center;
    align-items: center;
    text-align: center;
    z-index: 100;
    font-size: 1.6rem;
    font-weight: 600;
    letter-spacing: 0.04em;
  }

  canvas {
    display: block;
    background: #111;
    margin: 0 auto;
    border: 3px solid #eee;
    box-shadow: 0 0 20px #bbb;
    border-radius: 12px;
  }

  #hud {
    position: fixed;
    top: 15px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 22px;
    user-select: none;
    font-weight: 700;
    letter-spacing: 0.1em;
    background: #222;
    color: #eee;
    padding: 8px 24px;
    border-radius: 20px;
    box-shadow:
      inset 0 0 8px #555,
      0 4px 10px rgba(255,255,255,0.15);
    min-width: 180px;
    text-align: center;
    z-index: 5;
  }

  /* Overlay screens styles */
  .overlay-screen {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: rgba(0,0,0,0.95);
    color: #eee;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    font-weight: 700;
    letter-spacing: 0.1em;
    z-index: 10;
  }

  .overlay-screen.hidden {
    display: none;
  }

  .overlay-screen h1 {
    font-size: 3rem;
    margin-bottom: 24px;
    text-shadow: 0 0 12px #eee;
  }

  .overlay-screen p {
    font-size: 1.3rem;
    margin-bottom: 40px;
    text-shadow: 0 0 8px #aaa;
  }

  .btn {
    background: #eee;
    color: #111;
    border: none;
    padding: 14px 40px;
    font-size: 1.2rem;
    font-weight: 700;
    border-radius: 30px;
    cursor: pointer;
    letter-spacing: 0.08em;
    box-shadow:
      0 0 12px #eee,
      inset 0 -3px 0 #ccc;
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  .btn:hover,
  .btn:focus {
    background: #ddd;
    color: #000;
    outline: none;
  }
</style>
</head>
<body>
<div id="landscape-warning">Please rotate your device to landscape mode</div>

<div id="hud">Lives: 3 | Score: 0</div>

<canvas id="game"></canvas>

<!-- Home Screen -->
<div id="home-screen" class="overlay-screen">
  <h1>BRICK BREAKER</h1>
  <p>Use arrow keys or touch to move the paddle</p>
  <button id="start-btn" class="btn" tabindex="0">START GAME</button>
</div>

<!-- Game Over Screen -->
<div id="gameover-screen" class="overlay-screen hidden">
  <h1>GAME OVER</h1>
  <p id="final-score-text">Score: 0</p>
  <button id="restart-btn" class="btn" tabindex="0">RESTART</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const landscapeWarning = document.getElementById('landscape-warning');
  const hud = document.getElementById('hud');

  const homeScreen = document.getElementById('home-screen');
  const gameOverScreen = document.getElementById('gameover-screen');
  const startBtn = document.getElementById('start-btn');
  const restartBtn = document.getElementById('restart-btn');
  const finalScoreText = document.getElementById('final-score-text');

  let width, height;

  // Game variables
  let paddle, ball, bricks;
  const rows = 5;
  const cols = 8;
  const brickPaddingRatio = 0.02;

  let lives = 3;
  let score = 0;
  const maxScore = rows * cols;

  // Input tracking
  let leftPressed = false;
  let rightPressed = false;

  // Game state
  let isRunning = false;

  function initGameObjects() {
    paddle.width = width * 0.18;
    paddle.height = height * 0.025;
    paddle.x = (width - paddle.width) / 2;
    paddle.y = height * 0.9;
    paddle.speed = width * 0.02;

    ball.radius = width * 0.015;
    ball.x = width / 2;
    ball.y = paddle.y - ball.radius - 1;
    ball.speed = width * 0.008;
    ball.dx = ball.speed * (Math.random() > 0.5 ? 1 : -1);
    ball.dy = -ball.speed;

    bricks = [];
    let brickPadding = width * brickPaddingRatio;
    let brickWidth = (width - (cols + 1) * brickPadding) / cols;
    let brickHeight = height * 0.05;

    for (let r = 0; r < rows; r++) {
      bricks[r] = [];
      for (let c = 0; c < cols; c++) {
        bricks[r][c] = {
          x: brickPadding + c * (brickWidth + brickPadding),
          y: brickPadding + r * (brickHeight + brickPadding),
          width: brickWidth,
          height: brickHeight,
          status: 1
        };
      }
    }
  }

  function resetGame() {
    lives = 3;
    score = 0;
    initGameObjects();
    updateHUD();
  }

  function updateHUD() {
    hud.textContent = `Lives: ${lives} | Score: ${score}`;
  }

  function resize() {
    width = window.innerWidth;
    height = window.innerHeight;

    if (height > width) {
      landscapeWarning.style.display = 'flex';
      canvas.style.display = 'none';
      hud.style.display = 'none';
      homeScreen.classList.add('hidden');
      gameOverScreen.classList.add('hidden');
      isRunning = false;
    } else {
      landscapeWarning.style.display = 'none';
      canvas.style.display = 'block';
      hud.style.display = 'block';

      canvas.width = width;
      canvas.height = height;

      initGameObjects();
      updateHUD();

      if (!isRunning) {
        homeScreen.classList.remove('hidden');
      }
    }
  }

  // Paddle object
  paddle = {
    x: 0,
    y: 0,
    width: 0,
    height: 0,
    speed: 0
  };

  // Ball object
  ball = {
    x: 0,
    y: 0,
    radius: 0,
    dx: 0,
    dy: 0,
    speed: 0
  };

  // Input handlers
  document.addEventListener('keydown', e => {
    if (!isRunning) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = true;
    else if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = true;
  });
  document.addEventListener('keyup', e => {
    if (!isRunning) return;
    if (e.key === 'ArrowLeft' || e.key === 'a') leftPressed = false;
    else if (e.key === 'ArrowRight' || e.key === 'd') rightPressed = false;
  });

  // Keyboard handler for space key on focused buttons
  document.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      e.preventDefault();
      const activeElement = document.activeElement;
      if (activeElement === startBtn && !isRunning) {
        startBtn.click();
      } else if (activeElement === restartBtn && !isRunning) {
        restartBtn.click();
      }
    }
  });

  // Touch input
  canvas.addEventListener('touchmove', e => {
    if (!isRunning) return;
    e.preventDefault();
    if(e.touches.length > 0){
      const touchX = e.touches[0].clientX;
      paddle.x = touchX - paddle.width / 2;
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > width) paddle.x = width - paddle.width;
    }
  }, { passive: false });

  // Touch events for buttons to ensure tap works smoothly on mobile
  startBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    if (!isRunning) startBtn.click();
  }, { passive: false });

  restartBtn.addEventListener('touchstart', e => {
    e.preventDefault();
    if (!isRunning) restartBtn.click();
  }, { passive: false });

  function drawPaddle() {
    ctx.fillStyle = '#eee';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 6;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    ctx.lineJoin = 'round';
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#bbb';
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    ctx.strokeRect(paddle.x, paddle.y, paddle.width, paddle.height);
    ctx.shadowBlur = 0;
  }

  function drawBall() {
    const gradient = ctx.createRadialGradient(ball.x - ball.radius/2, ball.y - ball.radius/2, ball.radius/3, ball.x, ball.y, ball.radius);
    gradient.addColorStop(0, '#fff');
    gradient.addColorStop(1, '#aaa');

    ctx.beginPath();
    ctx.fillStyle = gradient;
    ctx.shadowColor = '#ddd';
    ctx.shadowBlur = 12;
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fill();
    ctx.closePath();
    ctx.shadowBlur = 0;
  }

  function drawBricks() {
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const b = bricks[r][c];
        if (b.status === 1) {
          const grad = ctx.createLinearGradient(b.x, b.y, b.x + b.width, b.y + b.height);
          grad.addColorStop(0, '#eee');
          grad.addColorStop(1, '#555');
          ctx.fillStyle = grad;

          const radius = 6;
          ctx.beginPath();
          ctx.moveTo(b.x + radius, b.y);
          ctx.lineTo(b.x + b.width - radius, b.y);
          ctx.quadraticCurveTo(b.x + b.width, b.y, b.x + b.width, b.y + radius);
          ctx.lineTo(b.x + b.width, b.y + b.height - radius);
          ctx.quadraticCurveTo(b.x + b.width, b.y + b.height, b.x + b.width - radius, b.y + b.height);
          ctx.lineTo(b.x + radius, b.y + b.height);
          ctx.quadraticCurveTo(b.x, b.y + b.height, b.x, b.y + b.height - radius);
          ctx.lineTo(b.x, b.y + radius);
          ctx.quadraticCurveTo(b.x, b.y, b.x + radius, b.y);
          ctx.closePath();

          ctx.shadowColor = '#aaa';
          ctx.shadowBlur = 8;
          ctx.fill();
          ctx.shadowBlur = 0;
          ctx.strokeStyle = '#777';
          ctx.lineWidth = 1.5;
          ctx.stroke();
        }
      }
    }
  }

  function collisionDetection() {
    // Ball and bricks
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        let b = bricks[r][c];
        if (b.status === 1) {
          if (
            ball.x + ball.radius > b.x &&
            ball.x - ball.radius < b.x + b.width &&
            ball.y + ball.radius > b.y &&
            ball.y - ball.radius < b.y + b.height
          ) {
            ball.dy = -ball.dy;
            b.status = 0;
            score++;
            updateHUD();

            if (score === maxScore) {
              setTimeout(() => {
                alert('🎉 You Win! Starting new game...');
                resetGame();
              }, 100);
            }
            return;
          }
        }
      }
    }

    // Ball and paddle
    if (
      ball.x > paddle.x &&
      ball.x < paddle.x + paddle.width &&
      ball.y + ball.radius > paddle.y &&
      ball.y - ball.radius < paddle.y + paddle.height
    ) {
      const hitPos = (ball.x - paddle.x) / paddle.width;
      const angle = (hitPos - 0.5) * Math.PI / 2;
      const speed = ball.speed;

      ball.dx = speed * Math.sin(angle);
      ball.dy = -speed * Math.cos(angle);
    }
  }

  function update() {
    if (leftPressed) paddle.x -= paddle.speed;
    if (rightPressed) paddle.x += paddle.speed;

    if (paddle.x < 0) paddle.x = 0;
    if (paddle.x + paddle.width > width) paddle.x = width - paddle.width;

    ball.x += ball.dx;
    ball.y += ball.dy;

    if (ball.x + ball.radius > width) {
      ball.x = width - ball.radius;
      ball.dx = -ball.dx;
    }
    if (ball.x - ball.radius < 0) {
      ball.x = ball.radius;
      ball.dx = -ball.dx;
    }
    if (ball.y - ball.radius < 0) {
      ball.y = ball.radius;
      ball.dy = -ball.dy;
    }

    if (ball.y - ball.radius > height) {
      lives--;
      updateHUD();
      if (lives <= 0) {
        isRunning = false;
        finalScoreText.textContent = `Score: ${score}`;
        gameOverScreen.classList.remove('hidden');
        hud.style.display = 'none';
      } else {
        paddle.x = (width - paddle.width) / 2;
        ball.x = width / 2;
        ball.y = paddle.y - ball.radius - 1;
        ball.dx = ball.speed * (Math.random() > 0.5 ? 1 : -1);
        ball.dy = -ball.speed;
      }
    }

    collisionDetection();
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);
    drawPaddle();
    drawBall();
    drawBricks();
  }

  function loop() {
    if (landscapeWarning.style.display === 'none' && isRunning) {
      update();
      draw();
    }
    requestAnimationFrame(loop);
  }

  startBtn.addEventListener('click', () => {
    resetGame();
    isRunning = true;
    homeScreen.classList.add('hidden');
    hud.style.display = 'block';
  });

  restartBtn.addEventListener('click', () => {
    resetGame();
    isRunning = true;
    gameOverScreen.classList.add('hidden');
    hud.style.display = 'block';
  });

  window.addEventListener('resize', resize);

  resize();
  loop();
})();
</script>
</body>
</html>
