<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Responsive Brick Breaker</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #222;
    }

    canvas {
      display: block;
      background: #111;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>

<script>
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  let width, height;
  let paddle, ball, bricks, rows = 5, cols = 8;
  let paddleWidthRatio = 0.2;
  let keys = { left: false, right: false };

  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;

    // Force landscape orientation
    if (height > width) [width, height] = [height, width];

    canvas.width = width;
    canvas.height = height;

    setupGame();
  }

  function setupGame() {
    paddle = {
      width: width * paddleWidthRatio,
      height: height * 0.02,
      x: width / 2 - (width * paddleWidthRatio) / 2,
      y: height - 40,
      speed: width * 0.01
    };

    ball = {
      x: width / 2,
      y: height / 2,
      radius: 10,
      dx: 4,
      dy: -4
    };

    bricks = [];
    let brickWidth = width / cols;
    let brickHeight = height * 0.05;

    for (let r = 0; r < rows; r++) {
      bricks[r] = [];
      for (let c = 0; c < cols; c++) {
        bricks[r][c] = { x: c * brickWidth, y: r * brickHeight + 30, status: 1 };
      }
    }
  }

  function drawPaddle() {
    ctx.fillStyle = "#0f0";
    ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
  }

  function drawBall() {
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
    ctx.fillStyle = "#0ff";
    ctx.fill();
    ctx.closePath();
  }

  function drawBricks() {
    ctx.fillStyle = "#f00";
    bricks.forEach(row => {
      row.forEach(brick => {
        if (brick.status) {
          ctx.fillRect(brick.x, brick.y, width / cols - 2, height * 0.05 - 2);
        }
      });
    });
  }

  function collisionDetection() {
    bricks.forEach(row => {
      row.forEach(brick => {
        if (brick.status) {
          if (
            ball.x > brick.x &&
            ball.x < brick.x + width / cols &&
            ball.y > brick.y &&
            ball.y < brick.y + height * 0.05
          ) {
            ball.dy *= -1;
            brick.status = 0;
          }
        }
      });
    });
  }

  function update() {
    // Paddle movement via keys
    if (keys.left) {
      paddle.x -= paddle.speed;
    }
    if (keys.right) {
      paddle.x += paddle.speed;
    }

    // Prevent paddle from going out of bounds
    if (paddle.x < 0) paddle.x = 0;
    if (paddle.x + paddle.width > width) paddle.x = width - paddle.width;

    // Ball movement
    ball.x += ball.dx;
    ball.y += ball.dy;

    // Wall collision
    if (ball.x + ball.radius > width || ball.x - ball.radius < 0) ball.dx *= -1;
    if (ball.y - ball.radius < 0) ball.dy *= -1;
    if (ball.y + ball.radius > height) setupGame(); // Reset on bottom hit

    // Paddle collision
    if (
      ball.y + ball.radius > paddle.y &&
      ball.x > paddle.x &&
      ball.x < paddle.x + paddle.width
    ) {
      ball.dy *= -1;
      ball.y = paddle.y - ball.radius;
    }

    collisionDetection();
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);
    drawPaddle();
    drawBall();
    drawBricks();
  }

  function gameLoop() {
    update();
    draw();
    requestAnimationFrame(gameLoop);
  }

  // Paddle movement handlers
  function movePaddle(x) {
    paddle.x = x - paddle.width / 2;
    if (paddle.x < 0) paddle.x = 0;
    if (paddle.x + paddle.width > width) paddle.x = width - paddle.width;
  }

  canvas.addEventListener("mousemove", (e) => movePaddle(e.clientX));
  canvas.addEventListener("touchmove", (e) => {
    if (e.touches.length > 0) movePaddle(e.touches[0].clientX);
  });

  // Keyboard input
  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowLeft") keys.left = true;
    if (e.key === "ArrowRight") keys.right = true;
  });

  window.addEventListener("keyup", (e) => {
    if (e.key === "ArrowLeft") keys.left = false;
    if (e.key === "ArrowRight") keys.right = false;
  });

  window.addEventListener("resize", resizeCanvas);

  // Start game
  resizeCanvas();
  gameLoop();
</script>
</body>
</html>
